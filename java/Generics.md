## Общее
Дженерик (параметризированный класс) - параметр, позволяющий использовать в коде объявления класса/метода обобщение, заменяющее определённый тип. Этот "кастомный" тип будет существовать только до компиляции в байткод, после чего будет заменён на `Object` с добавлением доп. логики в код.
Применяются дженерики для большей простоты и сохранения типобезопасности при работе с классами, оперирующими с разными типами. Они помогают избавится от ненужных кастов и, как следствие, от появления исключений в рантайме.

Объявление параметризированного класса, поля и метода с параметром
```java
public class Temp<T> {  
    public T data;  
  
    public Temp(T data) {  
        this.data = data;  
    }
}
```

## Стирание типов
Суть этой особенности в том, что внутри класса после компиляции не хранится никакой информации о его параметрах. Все типы-параметры кастятся напрямую к объектам. Так, `List<String>` и `List<Double>` в байткоде оба будут иметь вид `List<Object>`.
После компиляции в байткод вся информация о типах-параметрах стирается из программы. Это может приводить к трудноотслеживаемым ошибкам и нарушению типобезопасности.

Так, рассмотрим следующий код:
```java
public class TestClass<T> {  
    private T val1;  
    private T val2;  
  
    public void printValues() {  
        System.out.println(val1);  
        System.out.println(val2);  
    }  
  
    public static <T> TestClass<T> createAndAddValues(Object o1, Object o2) {  
        TestClass<T> result = new TestClass<>();  
        result.val1 = (T) o1;  
        result.val2 = (T) o2;  
        return result;  
    }  
  
    public static void main(String[] args) {  
        String s = "Test String";  
        Double d = 22.111;  
        TestClass<Integer> test = createAndAddValues(s, d);  
        test.printValues();  
    }  
}
```
В результате ошибки не произойдёт и в параметры объекта, типизированного как `Integer` попадут переменные `String` и `Double`.

Почему так произошло: в методе `main()` мы инициализировали объект нашего класса, типизированный как `Integer`. Мы присвоили ему значение, полученное из метода `createAndAddValues()`, в который передали `String` и `Double`. Так как аргументы метода - обджекты, ошибки компиляции не последовало.
Данная операция произошла в рантайме и ранее объявленный тип `T` превратился в тип `Object`, из-за чего мы кастанули аргументы не к `Integer`, а к `Object`. Таким образом в поля нашего объекта потенциально может попасть вообще любой объект.
**Вывод - зачастую кастовать к типу дженерика нет смысла, его всё равно сожрёт type erasure.**

#### Дженерики и массивы
Массивы, в отличие от дженериков, содержат информацию о хранимом типе и используют её. Из-за этого <ins>невозможно создать типизированный массив или массив типизированного класса</ins>.
Так, следующий код выдаст ошибку компиляции `generic array creation`:
```java
new List<T>[]
new List<String>[]
new T[]
```

#### Обход ограничений стирания типов
Допустим, нам надо создать метод, создающий и возвращающий объекты типа `T`. Обычным способом это сделать не получится т.к. информация о том, какой тип нам нужен сотрётся в рантайме.
Рабочим вариантом является использование типизированного класса `Class<T>`, который хранит в параметре информацию о том, какой класс он отражает. При помощи его метода `newInstance()` можно создать указанного класса. **Главное - чтобы у объекта был конструктор без параметров**
Следующий код создаёт объект класса `User`:
```java
public class TestClass<T> {  
    Class<T> typeParameterClass;  
  
    public TestClass(Class<T> typeParameterClass) {  
        this.typeParameterClass = typeParameterClass;  
    }  
  
    public T createInstance() throws InstantiationException, IllegalAccessException {  
        T t = typeParameterClass.newInstance();  
        return t;  
    }  
  
    public static void main(String[] args) throws InstantiationException, IllegalAccessException {  
        TestClass<User> testClass = new TestClass<>(User.class);  
        User u = testClass.createInstance();  
        System.out.println(u.getClass());  
    }  
}
```

## Raw типы
Сырой тип - типизированный класс, созданный вообще без указания типа. По сути представляет собой то, как работали с подобными классами до java 5. Теперь обращение к методам с параметрами будет выдавать предупреждение.
В приведённом куске кода "сырой" массив хранит объекты разных классов, представленные как `Object`. В результате будет выведен класс каждого хранимого объекта (классы сохраняются).
```java
List list = new ArrayList();  
list.add("sas");  
list.add(12);  
list.add(727.27);  
list.add(new Object());  
list.add((byte) 0);  
  
for (Object object : list) {  
    System.out.println(object.getClass());  
}
```

