## Виды интерфейсов
* Маркерный интерфейс - интерфейс, не объявляющий никаких методов. Используется для того, чтобы дать программе понять, что с объектом можно производить определённые действия. Пример: `Serializable`, `Cloneable`, `Remote`.
* Функциональный интерфейс - содержит только один абстрактный метод. Нужен для использования в лямбда-выражениях. Желательно помечать аннотацией `@FunctionalInterface`. Может содержать сколько угодно реализованных методов, главное чтобы был один абстракный.
* Остальные интерфейсы - все остальные интерфейсы без ограничений на объявляемые методы и поля.

## Функциональные интерфейсы
Такие интерфейсы должны содержать только один публичный абстрактный метод.
Для валидации на этапе компиляции используется аннотация `@FunctionalInterface`.
Встроенные функциональные интерфейсы:

| Название            | Метод                  | Функциональность                                                                                      |
| ------------------- | ---------------------- | ----------------------------------------------------------------------------------------------------- |
| `Predicate<T>`      | `boolean test(T t);`   | Проверяет, соблюдается ли для переданного объекта некоторое условие                                   |
| `Consumer<T>`       | `void accept(T t);`    | Совершает на основе аргумента некоторые действия и ничего не возвращает                               |
| `Supplier<T>`       | `T get();`             | Ничего не принимает и возвращает некоторый аргумент типа `T`                                          |
| `Function<T, R>`    | `R apply(T t);`        | Приводит аргумент типа `T` к типу `R` и возвращает его как результат                                  |
| `UnaryOperator<T>`  | `T apply(T t);`        | Выполняет над переданным аргументом какие то операции, после чего возвращает его                      |
| `BinaryOperator<T>` | `T apply(T t1, T t2);` | Проводит некоторую операцию над двумя объектами типа `T` после чего возвращает результат того же типа |
